#!/usr/local/bin/perl
#      $Id: make-autoloads,v 1.23 2004-04-29 02:31:17 cvs Exp $

=pod
=head1 NAME

make-autoloads

=head1 SYNOPSIS

 make-autoloads [options] | <filelist>
	
	produce an expression on STDOUT which can be evaluated to autoload
	all functions and macros defined in those modules.
	<filelist> is a list of emacs lisp modules.
	
=head1 DESCRIPTION

	options:
		--help		print usage
		--top		top of directory tree
		--prefix <prefix>	optional prefix for alist (default=basename($top))
		--version	print version

=cut

use Getopt::Long;
use Pod::Text;
use Cwd;
use File::Spec;
use File::Spec::Unix qw(catfile);

binmode STDOUT;

GetOptions(
	   'help' => \$opt_help,
	   'version' => \$opt_version,
	   'top|d=s' => \$opt_top,
	   'prefix=s' => \$opt_prefix
	   );

$opt_h && pod2usage( { -verbose => 2 });

if ($opt_version) {
# sadly gives goofy trailing $
#    $version="$Revision: 1.23 $";
    print "make-autoloads version 1.15\n";
    exit;
}

$top=$opt_top || getcwd;

if ($opt_prefix) {
    $prefix=$opt_prefix . "-";
}
else {
    split('/',$top);
    $prefix=$_[-1] . "-";
}

$alist_symbol=$prefix . "autoload-alist";

# todo: lexer?
# todo: grab doc strings too
print "(setq $alist_symbol `( \n";

foreach $fn (@ARGV) {
    if ($fn =~ /\.autoloads$/) {
	print "(load-file \"$fn\")\n";
    }
    else {
#	@path=split(?/?, $fn);
#	$f=pop(@path);
	$f=File::Spec::Unix->catfile($top,$fn);

	if (open(F, $fn)) {
	    binmode F;
	    print ";  $fn\n";
	    foreach (<F>) {
		foreach $def ("defun", "defmacro", "define-derived-mode") {
		    if (/^\($def/) {
			($pat, $func)=split;
			$func =~ s/[()]//g;
			print "($func \"$f\")\n";
		    }
		    close(F);
		}
	    }
	}
    }
}
print "))\n";

print "(mapcar '(lambda (x) (autoload (car x) (cadr x) nil t)) $alist_symbol)\n";

