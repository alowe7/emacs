#!/usr/local/bin/perl
#      $Id: make-autoloads,v 1.14 2002-12-23 17:42:15 cvs Exp $
use getopt;
binmode STDOUT;

getopt('-p:');
if ($opt_help) {
    print "
	usage: make-autoloads [options] | <filelist>
	
	options:
		--help		print usage
		--version	print version
		--prefix
		-p <prefix>	optional prefix for alist (default=basename(pwd()))

	<filelist> is a list of emacs lisp modules.
	produce an expression on STDOUT which can be evaluated to autoload
	all functions and macros defined in those modules.
";
    exit;
}
elsif ($opt_version) {
# sadly gives goofy trailing $
#    $version="$Revision: 1.14 $";
    print "make-autoloads version 1.9\n";
    exit;
}
elsif ($opt_prefix) {
    $prefix=$opt_prefix . "-";
}
elsif ($opt_p) {
    $prefix=$opt_p . "-";
}
else {
    $PWD=`pwd`;
    chop $PWD; 
    split('/',$PWD);
    $prefix=$_[-1] . "-";
}

$alist_symbol=$prefix . "autoload-alist";

# todo: grab doc strings too
print "(setq $alist_symbol `( ";

foreach $fn (@ARGV) {
    foreach $def ("defun", "defmacro", "define-derived-mode") {
	@path=split(?/?, $fn);
	$f=pop(@path);
	open(F, $fn);
	binmode F;
	foreach (<F>) {
	    if (/^\($def/) {
		($pat, $func)=split;
		if (($pat eq "(defun") ||
		    ($pat eq "(defmacro")) {
# clean up defs like (defun foo() ...)
		    $func =~ s/[()]//g;
		    print "($func \"$f\")\n";
		}
	    }
	    close(F);
	}
    }
}
print "))\n";

print "(mapcar '(lambda (x) (autoload (car x) (cadr x) nil t)) $alist_symbol)\n";

